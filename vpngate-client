#!/usr/bin/env python3

import argparse
import base64
import concurrent.futures
import csv
import io
import logging
import os
import signal
import socket
import subprocess
import sys
import tempfile
import time
import urllib.request

# The URL for the VPN list
VPN_LIST_URL = "http://www.vpngate.net/api/iphone/"
SPEED_TEST_URL = "https://cachefly.cachefly.net/10mb.test"

logger = logging.getLogger()

# sigwait() does not work unless the signals waited have a handler defined
# (default handler terminates the program).
signal.signal(signal.SIGUSR1, lambda a: a)


EU_COUNTRIES = ["AL", "AT", "BA", "BE", "BG", "CH", "CY", "DE", "DK", "EE",
                "ES", "FI", "FR", "GB", "GR", "HR", "HU", "IE", "IS", "IT",
                "LT", "LV", "MK", "MT", "NL", "NO", "PL", "PT", "RO", "RS",
                "SE", "SI"]


class VPN:
    """A VPN server."""

    def __init__(self, data, args):
        # Command Line Arguments
        self.args = args

        # Logging
        self.log = logging.getLogger("VPN:%s" % data["#HostName"])

        # VPN Information
        self.ip = data["IP"]
        self.country = data["CountryLong"]
        self.country_code = data["CountryShort"]

        # OpenVPN endpoint information
        self.proto = None
        self.port = None

        # OpenVPN Config
        conf = data["OpenVPN_ConfigData_Base64"]
        self.config = base64.b64decode(conf).decode("UTF-8")
        for line in self.config.splitlines():
            if line.startswith("remote"):
                # format: remote <ip> <port>
                _, ip, self.port = line.split(" ")

                # If the IP is different, something is not right.
                assert ip == self.ip

            elif line.startswith("proto"):
                # format: proto tcp|udp
                _, self.proto = line.split(" ")

        self.log.debug("New VPN: ip=%s, proto=%s port=%s country=%s (%s)",
                       self.ip, self.proto, self.port, self.country,
                       self.country_code)

    def is_listening(self):
        """Probes the VPN endpoint to see if it's listening."""
        if self.proto == "udp":
            # TODO: Implement udp probing.
            self.log.debug("Can't probe UDP servers")
            return True

        self.log.debug("Probing VPN endpoint")

        # Create a socket with a timeout.
        s = socket.socket()
        s.settimeout(self.args.probe_timeout / 1000)

        try:
            # Try to connect to the VPN endpoint.
            s.connect((self.ip, int(self.port)))
        except socket.timeout:
            self.log.debug("VPN endpoint did not respond to connection")
            return False
        finally:
            s.shutdown(socket.SHUT_RDWR)
            s.close()

        self.log.debug("VPN endpoint is listening")
        return True

    def connect(self):
        """Initiates and manages the connection to this VPN server.

        Returns:
            (boolean) True if the connection was established and used, False if
            the connection failed and the next server should be tried

        Throws:
            (KeyboardInterrupt) if the process was aborted by the user.
        """

        self.log.info("Connecting to VPN...")
        with tempfile.NamedTemporaryFile(mode="w") as conf:
            self.log.debug("Writing config to %s", conf.name)
            conf.write(self.config)

            cmd = self.build_ovpn_command(conf.name)

            # If not verbose, send the output to /dev/null
            vpn_stdout = None if self.args.verbose else subprocess.DEVNULL

            self.log.debug("Executing %s", cmd)
            with subprocess.Popen(cmd, stdout=vpn_stdout,
                                  start_new_session=True) as proc:
                # Wait for the VPN to initialize
                if not self.wait_for_vpn_ready(proc):
                    # VPN failed to initialize. Indicate the caller to try the
                    # next one.
                    return False

                # Perform a speedtest on the VPN
                self.speedtest()

                # Ask the user if she wishes to use this VPN.
                if not self.prompt_use_vpn():
                    self.terminate_vpn(proc)
                    return False

                self.log.info("Setup finished! Press CTRL+C to stop the VPN")

                # Wait for SIGINT indefinitely.
                signal.sigwait(set([signal.SIGINT]))

                self.log.info("Closing VPN connection.")
                self.terminate_vpn(proc)

            return True

    def build_ovpn_command(self, conffile):
        """Builds the openvpn command to connect to this VPN."""
        # Make openvpn send USR1 on VPN up and USR2 on VPN down
        pid = os.getpid()
        up = "/bin/kill -USR1 %i" % pid
        return ["openvpn",
                "--script-security", "2",
                "--route-up", up,
                "--config", conffile]

    def wait_for_vpn_ready(self, proc):
        """Waits until the VPN routes have been correctly set and the VPN is
           ready to be used.

        Arguments:
            (Popen) proc: The Popen object for the openvpn process.

        Returns:
            (boolean) True if the route is setup correctly and the VPN is ready
            to be used, False if the initialization timed out.

        Throws:
            (KeyboardInterrupt) if the process was aborted by the user.
        """

        # Wait for SIGUSR1 and SIGINT; if we did not wait for SIGINT, this
        # process would hang indefinitely if SIGINT is generated.
        sigs = set([signal.SIGUSR1, signal.SIGINT])
        sig = signal.sigtimedwait(sigs, self.args.vpn_timeout)
        if not sig:
            self.log.warning("VPN Initialization timed out.")
            self.terminate_vpn(proc)
            return False

        elif sig.si_signo == signal.SIGINT:
            self.log.info("Received SIGINT. Cleaning up...")
            self.terminate_vpn(proc)

            # sigtimedwait() supressed the interrupt; raise it to let the rest
            # of the program know the user wants out.
            raise KeyboardInterrupt

        else:
            # Sanity check
            assert sig.si_signo == signal.SIGUSR1

            # Got USR1 which marks that the VPN routes are up.
            self.log.info("VPN initialized!")

            return True

    def prompt_use_vpn(self):
        """Asks the user if she likes to continue using the VPN connection
           after speedtest.

            Returns:
                (boolean) True if the users wants to use this VPN, False if not

        """

        self.log.info("Would you like to use this VPN (No = CTRL+C, " +
                      "Yes = Any Key)?")
        try:
            input()
        except KeyboardInterrupt:
            return False

        return True

    def terminate_vpn(self, proc):
        """Terminates the given vpn process gracefully (or forcefully if the
           termination takes too long).

        Arguments:
            (Popen) proc: The Popen object for the openvpn process.
        """
        def terminated():
            """Checks if the process terminates in 5 seconds."""
            try:
                proc.wait(timeout=5)
            except subprocess.TimeoutExpired:
                return False

            return True

        self.log.info("Terminating VPN connection")
        proc.terminate()
        if not terminated():
            self.warning("Termination timed out. Killing the process.")
            proc.kill()
            if not terminated():
                self.log.critical("The VPN process can't be killed!")
                self.log.critical("Exiting...")
                sys.exit(1)

    def speedtest(self):
        """Performs a speed test on the VPN connection."""

        self.log.info("Performing connection speed test. Press CTRL+C to " +
                      "stop it.")
        try:
            speedtest()
        except KeyboardInterrupt:
            print("")

    def __str__(self):
        return "VPN(ip=%s, country=%s)" % (self.ip, self.country)


class VPNList:
    def __init__(self, args):
        self.args = args

        # Setup logging
        self.log = logging.getLogger("VPNList")

        # Fetch the list
        self.load_vpns()

        # Filter by country
        self.filter_by_country()

        # Filter out unresponsive servers
        self.filter_unresponsive_vpns()

    def load_vpns(self):
        """Loads the VPN list from vpngate.net and parses then to |self.vpns|.
        """
        self.log.info("Loading VPN list from %s", self.args.url)

        # Read the data
        req = urllib.request.urlopen(self.args.url)
        data = io.TextIOWrapper(req, encoding='utf8')

        # The first and last lines start with an asterix; ignore them
        rows = filter(lambda r: not r.startswith("*"), data)

        # Parse the CSV
        reader = csv.DictReader(rows)

        # Create VPN instances
        self.vpns = [VPN(row, self.args) for row in reader]
        self.log.info("Found %i VPN servers", len(self.vpns))

    def filter_by_country(self):
        """Filters the VPN list based on geographic information."""
        # Check if anything needs to be filtered

        filter_fn = None

        if self.args.eu:
            self.log.info("Filtering out non-Europe VPNs")
            filter_fn = lambda vpn: vpn.country_code in EU_COUNTRIES

        if self.args.us:
            self.log.info("Filtering out non-US VPNs")
            filter_fn = lambda vpn: vpn.country_code == "US"

        if self.args.country:
            country = self.args.country.upper()
            self.log.info("Filtering out non-%s VPNs", country)
            filter_fn = lambda vpn: vpn.country_code == country

        if filter_fn:
            self.vpns = list(filter(filter_fn, self.vpns))

    def filter_unresponsive_vpns(self):
        """Probes VPN servers listening on TCP ports and removes those who do
           not reply in timely manner from the list of available VPNs.
        """
        self.log.info("Filtering out unresponsive VPN servers")

        # The number of concurrent probes
        n = args.probes

        # Parallelize the probing to a thread pool
        with concurrent.futures.ThreadPoolExecutor(max_workers=n) as ex:
            futures = {ex.submit(vpn.is_listening): vpn for vpn in self.vpns}
            responding = []

            for future in concurrent.futures.as_completed(futures):
                vpn = futures[future]

                try:
                    # True if the VPN responded, False otherwise
                    if future.result():
                        responding.append(vpn)

                except:
                    self.log.exception("Availability probe failed")

        self.log.info("Found %i responding VPNs", len(responding))

        self.vpns = responding


def speedtest():
    """Performs a speedtest printing connection speeds in kb/s once every
       500ms.
    """
    req = urllib.request.urlopen(SPEED_TEST_URL)

    # Bytes since previous checkpoint
    bytes_read = 0

    # Previous moment the speed was calculated (seconds)
    prev_checkpoint = time.perf_counter()

    # Size of the chunks to read.
    chunk = 4096
    while 1:
        # Read the next chunk
        data = req.read(chunk)
        bytes_read += chunk

        if not data:
            break

        # See how long since last checkpoint
        delta_t = time.perf_counter() - prev_checkpoint

        if delta_t > 0.5:
            # Yield the current speed.
            kbps = bytes_read / delta_t / 1024
            print("Current Speed: % 5.1f kb/s" % kbps, end="\r")
            bytes_read = 0
            prev_checkpoint = time.perf_counter()


def parse_args():
    """Parses the command line arguments."""
    p = argparse.ArgumentParser(description="Client for vpngate.net VPNs")
    p.add_argument("--country", "-c", action="store",
                   help="A 2 char country code (e.g. CA for Canada) from " +
                        "which to look for a VPN.")
    p.add_argument("--probes", "-n", action="store", default=100, type=int,
                   help="Number of concurrent connection probes to send.")
    p.add_argument("--probe-timeout", "-p", action="store", default=1000,
                   type=int,
                   help="When probing, how long to wait for " +
                        "connection until marking the VPN as unavailable " +
                        "(milliseconds)")
    p.add_argument("--eu", "-e", action="store_true",
                   help="Only consider servers in Europe")
    p.add_argument("--us", "-a", action="store_true",
                   help="Only consider servers in United States. Shorthand " +
                        "for --country US")
    p.add_argument("--url", "-u", action="store", default=VPN_LIST_URL,
                   help="URL of the VPN list (csv)")
    p.add_argument("--verbose", "-v", action="store_true",
                   help="More verbose output")
    p.add_argument("--vpn-timeout", "-t", action="store", default=10, type=int,
                   help="Time to wait for a VPN to be established " +
                        "before giving up (seconds).")
    return p.parse_args()


def main(args):
    # Load VPN server list.
    vpnlist = VPNList(args)

    # Connect to them one-by-one and let the user decide which one to use.
    for vpn in vpnlist.vpns:
        logging.info("Connecting to %s", vpn)
        try:
            res = vpn.connect()
        except KeyboardInterrupt:
            break

        # The user was happy with this VPN, break the loop.
        if res:
            break

    logger.info("Exiting...")
    return 0

if __name__ == "__main__":
    args = parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    if args.eu and args.us and args.country:
        logging.error("Only one of --eu, --us, --country can be specified")
        sys.exit(1)

    sys.exit(main(args))
