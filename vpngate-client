#!/usr/bin/env python3

import argparse
import base64
import concurrent.futures
import csv
import io
import itertools
import logging
import os
import signal
import socket
import subprocess
import tempfile
import time
import urllib.request

# The URL for the VPN list
VPN_LIST_URL = "http://www.vpngate.net/api/iphone/"
SPEED_TEST_URL = "https://cachefly.cachefly.net/10mb.test"

logger = logging.getLogger()

# sigwait() does not work unless the signals waited have a handler defined
# (default handler terminates the program).
signal.signal(signal.SIGUSR1, lambda a: a)
signal.signal(signal.SIGUSR2, lambda a: a)


class VPN:
    """A VPN server."""
    VPN_READY_SIGS = set([signal.SIGUSR1, signal.SIGINT])

    def __init__(self, data, args):
        # Command Line Arguments
        self.args = args

        # Logging
        self.log = logging.getLogger("VPN:%s" % data["#HostName"])

        # VPN Information
        self.ip = data["IP"]
        self.country = data["CountryLong"]
        self.country_code = data["CountryShort"]

        # OpenVPN endpoint information
        self.proto = None
        self.port = None

        # OpenVPN Config
        conf = data["OpenVPN_ConfigData_Base64"]
        self.config = base64.b64decode(conf).decode("UTF-8")
        for line in self.config.splitlines():
            if line.startswith("remote"):
                # format: remote <ip> <port>
                _, ip, self.port = line.split(" ")

                # If the IP is different, something is not right.
                assert ip == self.ip

            elif line.startswith("proto"):
                # format: proto tcp|udp
                _, self.proto = line.split(" ")

        self.log.debug("New VPN: ip=%s, proto=%s port=%s country=%s (%s)",
                       self.ip, self.proto, self.port, self.country,
                       self.country_code)

    def is_listening(self):
        """Probes the VPN endpoint to see if it's listening."""
        if self.proto == "udp":
            # TODO: Implement udp probing.
            self.log.debug("Can't probe UDP servers")
            return True

        self.log.debug("Probing VPN endpoint")

        # Create a socket with a timeout.
        s = socket.socket()
        s.settimeout(self.args.probe_timeout / 1000)

        try:
            # Try to connect to the VPN endpoint.
            s.connect((self.ip, int(self.port)))
        except socket.timeout:
            self.log.debug("VPN endpoint did not respond to connection")
            return False
        finally:
            s.shutdown(socket.SHUT_RDWR)
            s.close()

        self.log.debug("VPN endpoint is listening")
        return True

    def connect(self):
        """Initiates and manages the connection to this VPN server.

        Returns:
            (boolean) True if the connection was established and used, False if
            the connection failed and the next server should be tried

        Throws:
            (KeyboardInterrupt) if the process was aborted by the user.
        """

        self.log.info("Connecting to VPN...")
        with tempfile.NamedTemporaryFile(mode="w") as conf:
            self.log.debug("Writing config to %s", conf.name)
            conf.write(self.config)

            cmd = self.build_ovpn_command(conf.name)

            # If not verbose, send the output to /dev/null
            vpn_stdout = None if self.args.verbose else subprocess.DEVNULL

            self.log.debug("Executing %s", cmd)
            with subprocess.Popen(cmd, stdout=vpn_stdout,
                                  start_new_session=True) as proc:
                # Wait for the VPN to initialize
                if not self.wait_for_vpn_ready(proc):
                    # VPN failed to initialize. Indicate the caller to try the
                    # next one.
                    return False

                # Perform a speedtest on the VPN
                self.speedtest()

                # Ask the user if she wishes to use this VPN.
                if not self.prompt_use_vpn():
                    self.terminate_vpn(proc)
                    return False

                self.log.info("Setup finished! Press CTRL+C to stop the VPN")

                # Wait for SIGINT indefinitely.
                signal.sigwait(set([signal.SIGINT]))

                self.log.info("Closing VPN connection.")
                self.terminate_vpn(proc)

            return True

    def build_ovpn_command(self, conffile):
        """Builds the openvpn command to connect to this VPN."""
        # Make openvpn send USR1 on VPN up and USR2 on VPN down
        pid = os.getpid()
        up = "/bin/kill -USR1 %i" % pid
        return ["openvpn",
                "--script-security", "2",
                "--route-up", up,
                "--config", conffile]

    def wait_for_vpn_ready(self, proc):
        """Waits until the VPN routes have been correctly set and the VPN is
           ready to be used.

        Arguments:
            (Popen) proc: The Popen object for the openvpn process.

        Returns:
            (boolean) True if the route is setup correctly and the VPN is ready
            to be used, False if the initialization timed out.

        Throws:
            (KeyboardInterrupt) if the process was aborted by the user.
        """

        # Wait for SIGUSR1 and SIGINT; if we did not wait for SIGINT, this
        # process would hang indefinitely if SIGINT is generated.
        sig = signal.sigtimedwait(VPN.VPN_READY_SIGS, self.args.vpn_timeout)
        if not sig:
            self.log.warning("VPN Initialization timed out.")
            self.terminate_vpn(proc)
            return False

        elif sig.si_signo == signal.SIGINT:
            self.log.info("Received SIGINT. Cleaning up...")
            self.terminate_vpn(proc)

            # sigtimedwait supressed the interrupt; raise it to let the rest
            # of the program know the user wants out.
            raise KeyboardInterrupt

        else:
            # Sanity check
            assert sig.si_signo == signal.SIGUSR1

            # Got USR1 which marks that the VPN routes are up.
            self.log.info("VPN initialized!")

            return True

    def prompt_use_vpn(self):
        """Asks the user if she likes to continue using the VPN connection
           after speedtest.

            Returns:
                (boolean) True if the users wants to use this VPN, False if not

        """

        self.log.info("Would you like to use this VPN (No = CTRL+C, " +
                      "Yes = Any Key)?")
        try:
            input()
        except KeyboardInterrupt:
            return False

        return True

    def terminate_vpn(self, proc):
        """Terminates the given vpn process gracefully (or forcefully if the
           termination takes too long).

        Arguments:
            (Popen) proc: The Popen object for the openvpn process.
        """
        def terminated():
            """Checks if the process terminates in 5 seconds."""
            try:
                proc.wait(timeout=5)
            except subprocess.TimeoutExpired:
                return False

            return True

        self.log.info("Terminating VPN connection")
        proc.terminate()
        if not terminated():
            self.warning("Termination timed out. Killing the process.")
            proc.kill()
            if not terminated():
                self.log.critical("The VPN process can't be killed!")
                self.log.critical("Exiting...")
                sys.exit(1)

    def speedtest(self):
        """Performs a speed test on the VPN connection."""

        self.log.info("Performing connection speed test")
        self.log.info("Press CTRL+C to stop the speed test.")

        try:
            speedtest()
        except KeyboardInterrupt:
            print("")

    def __str__(self):
        return "VPN(ip=%s, country=%s)" % (self.ip, self.country)


def speedtest():
    """Performs a speedtest printing connection speeds in kb/s once every
       500ms.
    """
    req = urllib.request.urlopen(SPEED_TEST_URL)

    # Bytes since previous checkpoint
    bytes_read = 0

    # Previous moment the speed was calculated (seconds)
    prev_checkpoint = time.perf_counter()

    # Size of the chunks to read.
    chunk = 4096
    while 1:
        # Read the next chunk
        data = req.read(chunk)
        bytes_read += chunk

        if not data:
            break

        # See how long since last checkpoint
        delta_t = time.perf_counter() - prev_checkpoint

        if delta_t > 0.5:
            # Yield the current speed.
            kbps = bytes_read / delta_t / 1024
            print("Current Speed: % 5.1f kb/s" % kbps, end="\r")
            bytes_read = 0
            prev_checkpoint = time.perf_counter()


def parse_args():
    """Parses the command line arguments."""
    p = argparse.ArgumentParser(description="Client for vpngate.net VPNs")
    p.add_argument("--probes", "-n", action="store", default=100, type=int,
                   help="Number of concurrent connection probes to send.")
    p.add_argument("--probe-timeout", "-p", action="store", default=1000,
                   type=int,
                   help="When probing, how long to wait for " +
                        "connection until marking the VPN as unavailable " +
                        "(milliseconds)")
    p.add_argument("--url", "-u", action="store", default=VPN_LIST_URL,
                   help="URL of the VPN list (csv)")
    p.add_argument("--verbose", "-v", action="store_true", default=False,
                   help="More verbose output")
    p.add_argument("--vpn-timeout", "-t", action="store", default=10, type=int,
                   help="Time to wait for a VPN to be established " +
                        "before giving up (seconds).")
    return p.parse_args()


def load_vpns(args):
    logger.info("Loading VPN list from %s", args.url)
    req = urllib.request.urlopen(args.url)
    data = io.TextIOWrapper(req, encoding='utf8')

    # The first line is garbage, the second line contains the header.
    rows = itertools.islice(data, 1, None)

    # Parse the CSV
    reader = csv.DictReader(rows)

    # Create VPN instances; the last line only contains "*" which is ignored
    vpns = [VPN(row, args) for row in reader if row["#HostName"] != "*"]

    logger.info("Found %i VPN servers", len(vpns))
    return vpns


def get_responding_vpns(vpns, args):
    logger.info("Pinging VPN services")
    with concurrent.futures.ThreadPoolExecutor(max_workers=args.probes) as ex:
        # Parallelize the probing to a thread pool
        futures = {ex.submit(vpn.is_listening): vpn for vpn in vpns}
        responding = []

        for future in concurrent.futures.as_completed(futures):
            vpn = futures[future]

            try:
                # True if the VPN responded, False otherwise
                if future.result():
                    responding.append(vpn)

            except:
                logger.exception("Ping failed")

    logger.info("Found %i responding VPNs", len(responding))

    return responding

if __name__ == "__main__":
    args = parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)
    else:
        logging.basicConfig(level=logging.INFO)

    # Load VPN server list.
    vpns = load_vpns(args)

    # Filter out unresponsive VPNs
    responding_vpns = get_responding_vpns(vpns, args)

    # Connect to them one-by-one and let the user decide which one to use.
    for vpn in responding_vpns:
        logging.info("Connecting to %s", vpn)
        try:
            res = vpn.connect()
        except KeyboardInterrupt:
            break

        # The user was happy with this VPN, break the loop.
        if res:
            break

    logger.info("Exiting...")
